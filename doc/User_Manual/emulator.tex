\documentclass[main.tex]{subfiles}
\begin{document}
\newpage
\setcounter{section}{5}
\section{Tuning the Emulator}

\subsection{Summary}

Smooth emulator finds a sample set of Taylor expansion coefficients that reproduce a set of observables at a set of training points. For a given observables, a particular sample set of coefficients gives the following emulated function:
\begin{align*}\eqnumber
E(\vec{\theta})&=\sum_{\vec{n}, s.t. \sum_in_i\le {\rm MaxRank}}\frac{d(\vec{n})}{(n_1+n_2+\cdots)!}
A_{\vec{n}}
\left(\frac{\theta_1}{\Lambda}\right)^{n_1}
\left(\frac{\theta_2}{\Lambda}\right)^{n_2}
\cdots.
\end{align*}
Here, $\theta_1\theta_2\cdots$ are the model parameters, scaled so that their priors range from -1 to +1, or if they are Gaussian, have unit variance. The degeneracy factor, $d(\vec{n})$ is the number of different ways to sum the powers $n_i$ to a given rank,
\begin{align*}\eqnumber
d(\vec{n})=\frac{n_1!n_2!\cdots}{(n_1+n_2+\cdots)!}.
\end{align*}

The emulator finds a predetermined number of sets of coefficients, where each set of coefficients provides a function that reproduces the real model at the training points. The User sets the number of sets of coefficients, typically of order $N_{\rm sample}\approx 10$, in a parameter file. Away from the training points, the uncertainty of the emulator is represented by the spread of the values amongst the $N_{\rm sample}$ predictions.

Smooth Emulator solves for the coefficients from the training data, then stores those coefficients in files for later use. Smooth Emulator can emulate either the full-model observables directly, or their principal components. Training the emulator follows the same steps for either approach. 

Before training the emulator, one must first run the full model at a given set of training points. In addition to a parameter file, which sets numerous options, the User must provide the following:
\begin{enumerate}\itemsep=0pt
    \item A file listing the names of observables, their uncertainties, and an estimate of the variance of each observable throughout the model-parameter space. This file will typically be {\tt Info/obs.txt}, where the path is relative to the project directory. 
    \item If the number of full-model runs performed is $N_{\rm train}$, Smooth emulator requires files for each run. Each file, typically {\tt modelruns/runI/mod\_parameters.txt} where $I$ varies from $1-N_{\rm train}$, describes the point in  parameter space for the $I^{\rm th}$ full-model run. 
    \item In the same directory, Smooth Emulator requires the observables calculated at the training points mentioned above. This information is provided in {\tt modelruns/runI/obs.txt}. 
\end{enumerate}
The parameter file, typically stored in {\tt parameters/emulator\_parameters.txt}, enables the User to select numerous option. For example, the User might use training data from a different directory, not {\tt modelruns/}, or might choose to use principal components rather than the observables directly. 

In the following subsections, we first review the format for each of the required input files, then describe how to run Smooth Emulator, how its output is stored, and how to switch PCA observables for the real observables.

\subsection{Smooth Emulator Parameters (not model parameters!)}

Smooth Emulator requires a parameter file. This can be located anywhere, as it will be specified on the command line when running Smooth Emulator, but is typically {\tt parameters/emulator\_parameters.txt}. The parameter file is simply a list, of parameter names followed by values. 

{\tt\begin{verbatim}
{\tt\begin{verbatim}
 SmoothEmulator_NPars 4
 SmoothEmulator_LAMBDA 3.0
 SmoothEmulator_MAXRANK 4
 SmoothEmulator_NMC 100000  # Steps between samples 
 SmoothEmulator_NASample 8  # No. of coefficient samples
 SmoothEmulator_TuneChooseMCMC true # set false if NPars<5
 SmoothEmulator_UseSigmaYRreal false # 
 SmoothEmulator_ConstrainA0 true
 SmoothEmulator_CutoffA false
 SmoothEmulator_ModelRunDirName modelruns
 SmoothEmulator_CoefficientsDirName coefficients
 Smooth_UseRFactor false
\end{verbatim}
}
\end{verbatim}
}

\begin{enumerate}\itemsep 0pt
\item {\bf SmoothEmulator\_LAMBDA}\\
This is the smoothness parameter $\Lambda$. It sets the relative importance of terms of various rank. If $\Lambda$ is unity or less, it suggests that the Taylor expansion converges slowly.
\item {\bf SmoothEmulator\_MAXRANK}\\
As Smooth Emulator assumes a Taylor expansion, this the maximum power of $\theta^n$ that is considered. Higher values require more coefficients, which in turn, slows down the tuning process.
\item {\bf SmoothEmulator\_SmoothEmulator_TuneChooseMCMC}\\
If set to {\tt false}, Smooth Emulator will set all but $N_{\rm train}$ coefficients randomly, according to their Gaussian prior. Then, it will solve for the remaining coefficients in order to fit the training data. The weight is calculated for the remaining coefficients, at which point the coefficients are kept or rejected proportional to the weight. The coefficients chosen in this manner are perfectly independent of one another, but at the cost of requiring many samplings before finding a weight to keep. This choice is efficient when the number of training points is small. If {\tt SmoothEmulator\_SmoothEmulator_TuneChooseMCMC} is set to {\tt true}, Smooth Emulator will choose the coefficients as a small random step from the previous coefficients, then keep or reject the coefficients according to a Metropolis algorithm. The downside is that many steps are required to create a sampling set of coefficients that are independent of one another. This method is preferable for larger numbers of training points. 
\item {\bf SmoothEmulator\_NMC}\\
When the previous parameter is set to {\tt true}, this sets the number of steps between retained samples of coefficients. For larger numbers of parameters, this should be set at many thousands. Higher values lead to more independent sets of coefficients, but the calculation then requires more time.  
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\item {\bf SmoothEmulator\_NPars}\\
\subsection{Code}

The Code uses a fake model which acts as a template used to represent a potential model. It will be replaced by the actual model created by the user. The file reads in the model prior info and the observable info files from the info directory and generates the observable text files in the run directory. 

To use the fake model run the following command in the terminal window in the project directory. 

{\tt 
\begin{verbatim}
    % fakemodel 
\end{verbatim}
}
 
\subsection{Writing Coefficients}

In the terminal window run the following command after the simplex and importing the model.

{\tt 
\begin{verbatim}
    % smoothy parameters/emulator_parameters.txt 
\end{verbatim}
}

This code is responsible for invoking the primary functionality that adjusts the training points for the model. It produces samples of coefficients, which are then arranged in a directory within the project directory that provides details about each observable and various coefficient values.

This function aims to perform a Markov Chain Monte Carlo (MCMC) parameter tuning process to optimize some coefficients of a smooth emulator. The code attempts to find the best set of coefficients that maximize the log probability of the emulator given some training data. 

Final Output and Results:
After completing the specified number of iterations, the algorithm calculates the success percentage (proportion of successful updates), the final value of SigmaA, and the log-likelihood normalized by the number of degrees of freedom (Ndof) for the best parameter set (BestLogP/Ndof).  

Interpreting the Results:
The success percentage gives an indication of the acceptance rate of new parameter sets during the MCMC process. A higher success rate generally indicates efficient parameter tuning. The value of SigmaA represents the estimated uncertainty or spread in the parameter space. The BestLogP/Ndof provides a measure of the goodness of fit achieved by the best parameter set. 

The function also updates statistics for the sampled variance (SigmaA) to calculate the average variance (SigmaAbar) over all the generated samples. In summary, It iteratively tunes the coefficients using MCMC and stores the optimized coefficient samples in a matrix for further analysis. It is used for the process of generating and analyzing samples for the smooth emulator.

The Code also Logs the comparison between the predicted value and the actual training data value for the current observable. Also, log the corresponding uncertainty. The function evaluates the smooth emulator's accuracy by generating predictions for each observable at the training points and comparing these predictions with the actual training data.  

The code also writes metadata about the number of parameters (NPars), maximum rank (MaxRank), and total number of coefficients (NCoefficients) to a file named "meta.txt" in the created directory. For each sample generated using the function, it writes the corresponding coefficients (parameters) to a separate file named "sampleX.txt" in the created directory, where "X" represents the sample index. The number of coefficients is equal to NCoefficients, and they are written in a column-wise format. 

\end{document}
