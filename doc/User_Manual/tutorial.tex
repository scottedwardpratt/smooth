\documentclass[UserManual.tex]{subfiles}
\begin{document}
\setcounter{section}{7}
\section{Template-Based Tutorial}\label{sec:tutorial}

\subsection{Overview}
A template project directory is provided that the User may copy to their own space, then use this as a foundation from which to embark on their own analysis. This directory includes information files, describing the parameter priors and the observables, that correspond to an artificial model that is also provided as a template. Working through the steps in this section constitutes a tutorial, both for running {\it Simplex Sampler} and for running {\it Smooth Emulator}.

This section describes the steps of how the User would
\begin{enumerate}\itemsep=0pt
\item Copy the required files from the template directory to the User's space, and compile the main programs.
\item Set up the information files describing the priors and observable names.
\item Run {\it Simplex Sampler} to generate the model-parameter values at which the full model will be trained.
\item Run a ``fake'' full model to generate the observables for each of the full-model runs.
\item Tune {\it Smooth Emulator} and write the coefficients to file.
\item Run a program that prompts the User for the coordinates of a point in parameter space, then returns the emulator prediction with its uncertainty.
\end{enumerate}

\subsection{Installation and Compilation}
After completing the necessary prerequisites listed in section \ref{sec:installation}[Installation] and following the steps outlined in section \ref{sec:installation}[Prerequisites] to install the required cmake, eigen, and gsl libraries, and setting the Home Environment Variable by creating the Home Directory as described in section \ref{sec:installation}[Making Home Directory and Setting Home Environment Variable], the user must proceed to clone the smooth and commonutils directories and compile the libraries, as explained in sections \ref{sec:installation}[Downloading] and [Compiling Libraries].

Then, the user can establish a personalized project directory by duplicating the project\_template directory onto their computer. The User should copy the directories {\tt GITHOME\_BAND\_SMOOTH/templates/mylocal} and {\tt GITHOME\_BAND\_SMOOTH/templates/myproject} to a location in their personal space. We will refer to the User's two new directories as {\tt \$\{MY\_LOCAL\}/} and {\tt \$\{MY\_PROJECTS\}/}. For the purpose of this tutorial, the User must compile three main programs. This requires first changing into the {\tt \$\{MY\_LOCAL\}/main\_programs/} directory and entering:\\
{\tt
\begin{verbatim}
   ${MY\_LOCAL}/main_programs% cmake .
   ${MY\_LOCAL}/main_programs% make simplex
   ${MY\_LOCAL}/main_programs% make smoothy_tune
   ${MY\_LOCAL}/main_programs% make smoothy_calcobs
\end{verbatim}
}
The reason these are compiled in the User's space, separate from the main libraries, is that the User may well wish to create their own main programs, and this arrangement allows the User to compile their own versions, while leaving the original programs from the templates directory unchanged. 

For the purpose of the tutorial, there are also some ``fake'' models included in the distribution. For the User's project the fake model, which is very fast numerically, will be replaced by their own numerically intensive model. To compile the fake model used in the tutorial the User should change into the {\tt \$\{MY\_LOCAL\}/main\_programs/} directory and enter:
{\tt
\begin{verbatim}
   ${MY\_LOCAL}/fakemodels% cmake .
   ${MY\_LOCAL}/fakemodels% make fakerhic
\end{verbatim}
}
This particular fake model has six model parameters and six observables, all with names in common use by the RHIC community. The output has absolutely no physical motivation, other than providing some arbitrary functions to emulate. The executable should appear in {\tt \$\{MY\_LOCAL\}/bin/}.

\subsection{Creating Necessary Info Files}
The User will run the software from the {\tt \$\{MY\_PROJECTS\}/} directory. Before a User can run {\it Simplex Sampler} they must create information files that describe the model-parameter priors and list the observable names. Both files are in the {\tt \$\{MY\_PROJECTS\}} directory. The first file is {\tt \$\{MY\_PROJECTS\}/Info/modelpar\_info.txt}. For the purposes of this tutorial, a file already exists,
{\tt
\begin{verbatim}
   compressibility         uniform  150   300
   etaovers                uniform  0.05  0.32
   initial_flow            uniform  0.3   1.2
   initial_screening       uniform  0.0   1.0
   quenching_length        uniform  0.5   2.0
   initial_epsilon         uniform  15.0  30.0
\end{verbatim}
}
This implies that the model has four parameters. The names, without much inspiration, are {\tt par1}, {\tt par2}, {\tt par3} and {\tt par4}. These names would normally be more descriptive, e.g. {\tt NuclearCompressibility}. The second entry in each line is either {\tt uniform} or {\tt gaussian}. If the parameter is {\tt uniform}, the last two numbers represent the range of the uniform prior, $x_{\rm min}$ and $x_{\rm max}$. If the second entry is {\tt gaussian} the third entry represents the center of the Gaussian distribution and the fourth represents the width. For a real model, the User would replace this model with one appropriate for their own model.

The second file is {\tt \$\{MY\_PROJECTS\}/Info/observable\_info.txt}. This describes output values from the model. In the template the file is
{\tt
\begin{verbatim}
   meanpt_pion    100      
   meanpt_kaon    200      
   meanpt_proton  300      
   Rinv           1.0      
   v2             0.2     
   RAA            0.5
\end{verbatim}
}
The first entry in each line simply provides the names of the observable which will be processed in the Bayesian analysis.  The third entry is used by {\tt Smooth Emulator} during tuning, but only if a Monte Carlo method is used. The spread, $\sigma_A$, describes the variance of the output due to a single term in the Taylor expansion. Because this is treated as a random variable, and varied from one sampling of the coefficients to another, one must have an initial choice for it before the MCMC procedures in the tuning can proceed. One simply needs to choose this value within a few factors of two from the optimized value. Otherwise, the initial burn-in stage of the MCMC might require more time to coverge in the right neighborhood. Once the burn-in of the MCMC procedure is completed, this parameter is not used. If the analytical method is used for tuning (which is recommended) this parameter is irrelevant.

\subsection{Running {\it Simplex Sampler}}

Both {\it Simplex Sampler} and {\it Smooth Emulator} have options. These are provided in parameter files. For this tutorial, the provided parameter file is {\tt \$\{MY\_PROJECTS\}/parameters/simplex\_parameters.txt}. The provided file is
{\tt
\begin{verbatim}
   #Simplex_LogFileName    simplexlog.txt # comment out to direct output to screen
   Simplex_TrainType       1              # Must be 1 or 2             
   Simplex_ModelRunDirName modelruns      # Directory with training pt. info
\end{verbatim}
}
Because the first line is commented, the output of {\it Simplex Sampler} will be to the screen. Otherwise it would go to the specified file. By setting {\tt Simplex\_TrainType=1}, the sampler will choose $n+1$ training points, where $n=4$ is the number of model parameters. Each point corresponds to the vertices of an $n+1$ dimensional simplex.  Finally, the parameter {\tt Simplex\_ModelRunDirName} is set to ``{\tt modelruns}''. This informs {\tt Simplex Sampler} to write the coordinates of each training point and the corresponding observables in the directory {\tt \$\{MY\_PROJECTS\}/rhic/modelruns/}. 

Now the user can run {\tt Simplex Sampler}, which must be run from the project directory,
 {\tt
\begin{verbatim}
   ${MY_PROJECTS}/rhic% ${MY_LOCAL}/bin/simplex
\end{verbatim}
}
If all goes, well there is no screen output. The programs writes information about the training points in the {\tt modelruns/} directory. Changing into that directory, there should now be five directories, corresponding to the training points at 5 places: {\tt modelruns/run0}, {\tt modelruns/run1}, {\tt modelruns/run2}, {\tt modelruns/run3}, and {\tt modelruns/run4}. Each directory has one text file describing the training points. For example, the {\tt modelruns/run0/mod\_parameters.txt} file might be 
{\tt
\begin{verbatim}
   compressibility 190.282
   etaovers 0.14892
   initial_flow 0.664958
   initial_screening 0.426807
   quenching_length 1.16036
   initial_epsilon 21.7424
\end{verbatim}
}
This describes the six model parameters, which will serve as the input for the first full model run. If one had set the parameter {\tt Simplex\_TrainType} to 2, there would be 15 sub-directories in {\tt modelruns/}. The next step will be to run the full model for the parameters in each directory. Thus for {\tt Simplex\_Traintype=1}, one would need 5 full-model runs, and for {\tt Simplex\_Traintype=2}, one would need to do 15 full-model runs. The corresponding observables will be written in the files {\tt modelruns/runI/obs.txt}

\subsection{Running the Fake Full Model}
Once the training points have been generated, the user will input a Real full model based on the given structure, tailored to address their specific problem. For the tutorial, a fake model is provided. It reads the model-parameter values in each {\tt modelruns/runI/mod\_parameters.txt} file and writes the corresponding observables in {\tt modelruns/runI/obs.txt}. 

The fake model is a simple python script, which is enacted by entering the command:

{\tt
\begin{verbatim}
   ${MY_PROJECTS}/rhic% ${MY_LOCAL}/bin/fakerhic
\end{verbatim}
}
The output should appear as

{\tt
\begin{verbatim}
   ${MY_PROJECTS}/rhic% python3 ${MY_LOCAL}/fakemodel/templatemod.py
   ${MY_PROJECTS}/rhic% Writing: length 10.871583624279312 1.0
   ${MY_PROJECTS}/rhic% Writing: mass -48.906793378963606 1.0
   ${MY_PROJECTS}/rhic% Writing: time -50.76565279455246 1.0

   ${MY_PROJECTS/rhic}% Writing: length -27.67701646408149 1.0
   ${MY_PROJECTS}/rhic% Writing: mass -50.35567713223607 1.0
   ${MY_PROJECTS}/rhic% Writing: time -34.04264570717603 1.0
   .
   .
\end{verbatim}
}
Inspecting the {\tt modelruns/run0/obs.txt} file,

{\tt
\begin{verbatim}
   length 10.871583624279312 1.0
   mass  -48.906793378963606 1.0
   time  -50.76565279455246  1.0
\end{verbatim}
}
The second entry of each line is the value of the specified observable for that specific training point. The last entry is the random uncertainty associated with the full model. This is only relevant if the model has random fluctuations, meaning the re-running the model at the same point might result in different output. For this tutorial, the emulator will not consider such fluctuations (there is an emulator parameter that can be set to either consider the randomness or ignore it), so the third entry on each line is superfluous.

\subsection{Running {\it Smooth Emulator}}
To tune the emulator, the User will run {\tt \$\{MY\_LOCAL\}/bin/SmoothEmulator\_tune} which should have been compiled in the directions above. The User needs to edit one additional file a this point, the parameter file that sets numerous options for {\it Smooth Emulator}. For the template used in this tutorial, that file is

{\tt
\begin{verbatim}
#SmoothEmulator_LogFileName smoothlog.txt
 SmoothEmulator_LAMBDA 3.0
 SmoothEmulator_MAXRANK 4
 SmoothEmulator_NASample 8  # No. of coefficient samples
 SmoothEmulator_TuneChooseMCMC true # set false if NPars<5
 SmoothEmulator_UseSigmaYRreal false # 
 SmoothEmulator_ConstrainA0 false
 SmoothEmulator_CutoffA false
 SmoothEmulator_ModelRunDirName modelruns
 SmoothEmulator_CoefficientsDirName coefficients
 SmoothEmulator_ModelParInfoDir    Info
 SmoothEmulator_ObservableInfoDir  Info
 SmoothEmulator_TrainingPts 0-4
 SmoothEmulator_MCStepSize 0.01
 SmoothEmulator_MCSigmaAStepSize 50.0
 SmoothEmulator_NMC 10000  # Steps between samples 
 SmoothEmulator_UsePCA   false
\end{verbatim}
}
The parameters are described in detail in Sec. \ref{sec:emulator}. For the purpose of this tutorial we review a few of them. The parameter {\tt SmoothEmulator\_TrainingPts} is set above to include all five of the training points. However, if {\it Simplex Sampler} were run with a different choice, or if the User had added more points to be used by some other means, this parameter should be adjusted. The three parameters, {\tt SmoothEmulator\_MCStepSize}, {\tt SmoothEmulator\_MCSigmaAStepSize} and {\tt SmoothEmulator\_NMC} might be adjusted depending on the rate of Monte Carlo convergence of the tuning.

Now, running {\tt smoothy\_tune}, produces the following output,

{\tt
\begin{verbatim}
${MY_PROJECTS}/rhic% ${MY_LOCAL}/bin/smoothy_tune parameters/emulator_parameters.txt
 Tuning Emulator for length
 success percentage=30.900000, SigmaA=170.951454, logP/Ndof=-0.604220,BestLogP/Ndof=-0.482655
 success percentage=29.980000, SigmaA=842.098167, logP/Ndof=-0.731110,BestLogP/Ndof=-0.544052
 success percentage=30.840000, SigmaA=184.488302, logP/Ndof=-0.651830,BestLogP/Ndof=-0.528882
 success percentage=31.330000, SigmaA=151.392117, logP/Ndof=-0.784629,BestLogP/Ndof=-0.583911
 success percentage=30.120000, SigmaA=120.719517, logP/Ndof=-0.588851,BestLogP/Ndof=-0.481046
 success percentage=29.950000, SigmaA=178.510175, logP/Ndof=-0.671494,BestLogP/Ndof=-0.495041
 success percentage=29.710000, SigmaA=281.210451, logP/Ndof=-0.750559,BestLogP/Ndof=-0.605111
 success percentage=29.930000, SigmaA=171.487852, logP/Ndof=-0.599591,BestLogP/Ndof=-0.521237
 Tuning Emulator for mass
 success percentage=19.490000, SigmaA=53.649126, logP/Ndof=-0.625247,BestLogP/Ndof=-0.492470
 success percentage=19.910000, SigmaA=84.204171, logP/Ndof=-0.656591,BestLogP/Ndof=-0.527139
 success percentage=17.380000, SigmaA=46.138790, logP/Ndof=-0.780594,BestLogP/Ndof=-0.573535
 success percentage=18.750000, SigmaA=92.444543, logP/Ndof=-0.531562,BestLogP/Ndof=-0.505887
 success percentage=19.190000, SigmaA=60.575128, logP/Ndof=-0.540636,BestLogP/Ndof=-0.457436
 success percentage=17.920000, SigmaA=75.219279, logP/Ndof=-0.674120,BestLogP/Ndof=-0.539112
 success percentage=18.360000, SigmaA=40.116381, logP/Ndof=-0.656642,BestLogP/Ndof=-0.557670
 success percentage=19.470000, SigmaA=74.261850, logP/Ndof=-0.675975,BestLogP/Ndof=-0.564430
 Tuning Emulator for time
 success percentage=19.760000, SigmaA=82.486706, logP/Ndof=-0.669089,BestLogP/Ndof=-0.489885
 success percentage=19.970000, SigmaA=44.492860, logP/Ndof=-0.632434,BestLogP/Ndof=-0.497695
 success percentage=19.520000, SigmaA=80.956164, logP/Ndof=-0.682640,BestLogP/Ndof=-0.549880
 success percentage=19.340000, SigmaA=70.625835, logP/Ndof=-0.668105,BestLogP/Ndof=-0.518805
 success percentage=19.590000, SigmaA=116.988915, logP/Ndof=-0.673993,BestLogP/Ndof=-0.582763
 success percentage=19.080000, SigmaA=89.891122, logP/Ndof=-0.631130,BestLogP/Ndof=-0.508224
 success percentage=19.880000, SigmaA=102.710384, logP/Ndof=-0.707850,BestLogP/Ndof=-0.542698
 success percentage=19.450000, SigmaA=206.622539, logP/Ndof=-0.800493,BestLogP/Ndof=-0.486518
\end{verbatim}
}

If the success percentage above is small, much less than 50\%, then one may wish to decrease the Monte Carlo stepsizes, {\tt SmoothEmulator\_MCStepSize} and {\tt SmoothEmulator\_MCSigmaAStepSize 0.01}, to increase the success rate of the Metropolis steps. If the percentage is large, much greater than 50\%, conversely, one may wish to increase the step size to increase the coverage of the Monte Carlo trace. The quantity {\tt SigmaA} represents the characteristic width of the distributions of coefficients. It is allowed to vary, and from experience, the range can be quite large. If the value of {\tt SigmaA} does not seem to have randomized, one may wish to increase the number of Monte Carlo steps, {\tt  SmoothEmulator\_NMC}. The quantitiy {\tt logP/Ndof} is the logarithm of the weight for a coefficient set divided by the number of degrees of freedom (number of coefficients). It should fluctuate throughout the trace. Higher values (usually less negative) indicate better fits. If the value is well below -1, and rising throughout the trace, it suggests the burn-in was insufficient and {\tt  SmoothEmulator\_NMC} should be increased. The last entry in the output lines, {\tt BestLogP/Ndof}, simply reports the highest weight encountered in the trace. Again, if that is significantly increasing throughout the trace, {\tt  SmoothEmulator\_NMC} should be increased. 

To represent the uncertainty, there were $N_{\rm sample}$ sets of coefficients generated by {\it Smooth Emulator}. In this case, the parameter {\tt SmoothEmulator\_NASample} was set to 8. As the Monte Carlo trace proceeds, after {\tt SmoothEmulator\_NMC} steps, the coefficients are stored, and an output line is generated as seen above. Thus there are 8 lines printed above for each observable.

The program generates Taylor coefficients which are saved in the {\tt coefficients} directory. Each observable has its own sub-directory with its name. Besides the coefficients, {\it Smooth Emulator} also produces a {\tt meta.txt} file in the same directory. It includes essential information like the observable's maximum rank and net number of model parameters. This file is used to access the coefficients later. In this case, {\tt smoothy\_tune} created the directories, {\tt coefficients/rhic/RAA}, {\tt coefficients/Rinv}, {\tt coefficients/menapt\_kaon}, {\tt coefficients/meanpt_pion}, {\tt coefficients/meanpt_proton} and {\tt coefficients/v2}. Within each of these sub-directories {\tt smoothy\_tune} created files {\tt meta.txt}, {\tt ABest.txt} and {\tt BetaBest.txt}. The number or parameters, the maximum rank of the Taylor expansion and the overall number of Taylor coefficients are give in {\tt meta.txt}. The file {\tt ABest.txt} lists the actual coefficients of the Taylor expansion, and {\tt BetaBest.txt} gives an array used to calculate the uncertainty. If one of the Monte Carlo methods is chosen, rather than the default, the file {BetaBest.txt} is replaced by several files, {\tt sample0.txt, sample1.txt}$\cdots$, which provide several samples of Taylor coefficients. For the tutorial, the parameter file {\tt parameters/emulator\_parameters.txt} has the parameters set to use apply analytic tuning rather than Monte Carlo tuning.

\section{Generating Emulated Observables}
Finally, now that the emulator is tuned, one may wish to generate emulated values for the observables for specified points in model-parameter space. A sample program, {\tt \$\{MY\_LOCAL\}/bin/smoothy\_calcobs} is provided to illustrate how this can be accomplished. If one invokes the executable, using the same parameters as those used by {\tt smoothy\_tune}, the User is prompted to enter the coordinates of a point in model-parameter space, after which {\tt smoothy\_calcobs} prints out the observables. In this case, for the case where {\tt par1=20}, {\tt par2=40}, {\tt par3=60} and {\tt par4=80},

{\tt
\begin{verbatim}
${MY_PROJECTS}/rhic% ${MY_LOCAL}/bin/smoothy_calcobs parameters/emulator_parameters.txt
Prior Info
#         ParameterName Type   Xmin_or_Xbar  Xmax_or_SigmaX
 0:            par1   uniform          0        100
 1:            par2   uniform          0        100
 2:            par3   uniform          0        100
 3:            par4   uniform          0        100
Enter value for par1:
20
Enter value for par2:
40
Enter value for par3:
60
Enter value for par4:
80
length = 61.349 +/- 5.14857
mass = -26.4496 +/- 2.6206
time = -44.9779 +/- 2.0495
\end{verbatim}
}

One can test the emulator by entering the coordinates of training point. For example, one of the training points is {\tt par1=50}, {\tt par2=50}, {\tt par3=88.7298} and {\tt par4=40}. Running {\tt smoothy\_calcobs} for that coordinate,

{\tt
\begin{verbatim}
${MY_PROJECTS}/rhic% ${MY_LOCAL}/bin/smoothy_calcobs parameters/emulator_parameters.txt
Prior Info
#         ParameterName Type   Xmin_or_Xbar  Xmax_or_SigmaX
 0:            par1   uniform          0        100
 1:            par2   uniform          0        100
 2:            par3   uniform          0        100
 3:            par4   uniform          0        100
Enter value for par1:
50
Enter value for par2:
50
Enter value for par3:
88.7298
Enter value for par4:
40
length = -45.878 +/- 6.7435e-07
mass = -7.8083 +/- 8.42937e-08
time = -52.4031 +/- 1.16801e-06
\end{verbatim}
}
Note that the uncertainties for the emulation are not effectively zero, as each set of the 8 sets of coefficients provides an an emulator that exactly reproduces the training points.

Of course, it is unlikely the User will wish to enter model parameters interactively as was done above. To incorporate {\tt Smooth Emulator} into other programs, the User should inspect the main programs, e.g. {\tt \$\{MY\_LOCAL\}/main\_programs/smoothy\_calcobs\_main.cc}. The User can then design their own program based on this source code, and compile and link it by editing {\tt \$\{MY\_LOCAL\}/main\_programs/CMakeLists.txt}. By editing the CMake file, replacing the lines unique to {\tt smoothy\_calcobs}, one can easily compile new executables based on the User's main programs. To understand what might be involved, the source code in {\tt \$\{MY\_LOCAL\}/main\_programs/SmoothEmulator\_calcobs\_main.cc} is
{\tt
\begin{verbatim}
#include "msu_commonutils/parametermap.h"
#include "msu_smooth/master.h"
#include "msu_commonutils/log.h"
using namespace std;

 int main(int argc,char *argv[]){
   if(argc!=2){
      CLog::Info("Usage smoothy_calcobs emulator parameter filename");
      exit(1);
   }
   CparameterMap *parmap=new CparameterMap();
   parmap->ReadParsFromFile(string(argv[1]));
   CSmoothMaster master(parmap);
   master.ReadCoefficientsAllY();
   
   CModelParameters *modpars=new CModelParameters(master.priorinfo); // contains info about single point
   
   master.priorinfo->PrintInfo();
   // Prompt user for model parameter values
   vector<double> X(modpars->NModelPars);
   for(int ipar=0;ipar<modpars->NModelPars;ipar++){
      cout << "Enter value for " << master.priorinfo->GetName(ipar) << ":\n";
      cin >> X[ipar];
   }
   modpars->SetX(X);
   
   //  Calc Observables
   CObservableInfo *obsinfo=master.observableinfo;
   vector<double> Y(obsinfo->NObservables);
   vector<double> SigmaY(obsinfo->NObservables);
   master.CalcAllY(modpars,Y,SigmaY);
   for(int iY=0;iY<obsinfo->NObservables;iY++){
      cout << obsinfo->GetName(iY) << " = " << Y[iY] << " +/- " << SigmaY[iY] << endl;
   }

   return 0;
}
\end{verbatim}
}
This illustrates how one can write a code that 
\begin{itemize}\itemsep=0pt
\item[a)] Reads the parameter file
\item[b)] Creates a {\it master} emulator file (called master because it includes emulators for all the observables)
\item[c)] Creates a model-parameters object, {\tt modpars}, that stores the coordinates of the model-parameter point
\item[d)] Calculates the observables from the emulator
\end{itemize}


\end{document}
