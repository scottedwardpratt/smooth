\documentclass[UserManual.tex]{subfiles}
\begin{document}

\section{Installation and Getting Started}\label{sec:installation}

\subsection{Overview}
This section describes how to download and install {\it Smooth Emulator} software. The software is downloaded as part of the BAND git repository. {\it Smooth Emulator} software is all contained within a single directory of that repository. Once that directory resides locally on the User's computer. The software is divided into two directories. One holds the great majority of the header files and source code. The User might, or might not, wish to copy this directory to a new location outside of the repository. It is not expected that the User would edit these files, but if so, it would make sense to copy them. A second set of codes is meant to be copied into a new location. This includes the source codes for the main programs, which tend to be very short. It is expected that the User would likely edit these codes or make altered copies. The repository also includes a template directory, which the User can copy multiple times to serve as a starting point for different analyses. The template also serves as a starting point for the tutorial described in Sec. \ref{sec:tutorial}.

\subsection{Prerequisites}
{\it Smooth Emulator} programs should run on UNIX, Mac OS or Linux, but is not supported for Windows OS. The software is largely  written in C++, though there are some Python scripts for plotting results. In addition to a C++ compiler (CMake files assume you can accommodate the  C++ 20 standard), the user needs the following software installed.
\begin{itemize}\itemsep=0pt
    \item git
    \item CMake
    \item Eigen3 (Linear Algebra Package)
    \item Python/Matplotlib (for generating plots)
    \item pybind11 (To call emulator from within Python script)
    \item PDF viewer
\end{itemize}
CMake is an open-source, cross-platform build system that helps automate the process of compiling and linking for software projects. Hopefully, CMake will perform the needed gymnastics to find the Eigen3 installation. To install CMake, either visit the CMake website (https://cmake.org/), or use the system's package manager for the specific system. For example, on Mac OS, if one uses {\it homebrew} as a package manager, the command is
\vspace*{-8pt}{\tt
\begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{brew install cmake}
\end{Verbatim}
}\vspace*{-8pt}
Eigen is a C++ template library for vector and matrix math, i.e. linear algebra. The user can visit the Eigen website (\url{https://eigen.tuxfamily.org/dox/}), or use their system's package manager. For example on Mac OS with {\it homebrew},
\vspace*{-8pt}{\tt
\begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{brew install eigen}
\end{Verbatim}
}\vspace*{-8pt}

The providing plotting scripts are written in Python using Matplotlib. Most systems typically include Python, but Matplotlib often requires installation. On some systems Matplotlib can be added via the {\tt pip} Python package manager. In other cases it can be added via the system package manager directly. Some Users may wish to call {\it Smooth Emulator} functionality from within a Python script, most likely if they have their own MCMC software but want to call a function that returns a prediction and uncertainty for the observables as a function of the model parameters. The foundation for doing this is provided in the release, but requires installing pybind11. This can also be installed via {\tt pip}. It is crucial that pybind11 be installed consistently with the version of Python being used. On a Mac, one can consistently install all the required packages from the system package manager, {\it homebrew}.
\vspace*{-8pt}{\tt
\begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{brew install python}
% \textcolor{darkred}{brew install numpy}
% \textcolor{darkred}{brew install python-matplotlib}
% \textcolor{darkred}{brew install pybind11}
\end{Verbatim}
}\vspace*{-8pt}
Because pybind11 installation is often fraught with compatibility problems, it is not recommended to bother with its installation unless the User wishes to call the emulator from within a Python script.

A PDF viewer will be necessary to view the plots generated by the Python scripts above. Also, the software-testing script calls the PDF viewers to compare figures with previously generated ones. On the Mac, it calls Preview. For Linux it looks for either Okular or Evince. If those are not installed the User can simply compare the PDF files by hand.

\subsection{Downloading the Repository and Creating Working Directories}

The software requires downloading the BAND framework software repository into some directory. Should that be in the User's home directory, the User might enter
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{git clone https://github.com/bandframework/bandframework.git}
\end{Verbatim}
}\vspace*{-8pt}
Within the repository, there will be a directory\\{\tt /Users/CarlosSmith/bandframework/software/SmoothEmulator/}. All the relevant functionality of {\it Smooth Emulator} is contained within this directory. The User can either leave this directory in place, or make a copy to a new location. If the User plans on making changes on the underlying software and rebuilding the core libraries, it would make sense to copy this directory to a new location. If the User plans only to make edits to the short main programs (which will be relocated anyways) then the User might wish to simply use the repository version. Throughout the manual the phrase {\tt \$\{SMOOTH\_HOME\}} will refer to this directory. 

The User should create a personal directory from which the User would perform an analysis. This is most easily accomplished by copying the analysis template directory from the {\it Smooth} distribution. For example
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{cp -r $\{SMOOTH_HOME\}/AnalysisTemplate /Users/CarlosSmith/MY_ANALYSIS}
\end{Verbatim}
}\vspace*{-8pt}
The User may choose any other name besides {\tt MY\_ANALYSIS}. Hence forth, {\tt \$\{MY\_ANALYSIS\}} is a name chosen by the User, and will refer to this directory, including the path, from which the User will perform most of the analysis. Thus, the User may wish to have several such directories, located according to the User's preference. Any time a new analysis is performed with new parameters, and if the User wishes to save the previous analysis, a new {\tt \$\{MY\_ANALYSIS\}} directory should be created.

The User should create a second personal directory from which they will store their main programs and executables. A template should be copied from the repository as well.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{cp -r $\{SMOOTH_HOME\}/LocalTemplate /Users/CarlosSmith/mylocal}
\end{Verbatim}
}\vspace*{-8pt}
The User may choose any other name besides {\tt mylocal}, and henceforth, {\tt\$\{SMOOTH\_LOCAL\}} will refer to this directory, including its path. {\tt\$\{SMOOTH\_LOCAL\}/software/} contains the source code and CMake files for compiling the main programs. Executables will be stored in {\tt\$\{SMOOTH\_LOCAL\}/bin/}. Because the User might wish to edit the main programs, or to add similar programs, this provides the User a space to make such edits, all while leaving an original copy of the directory in the main repository. The User may find it convenient to add {\tt \$\{SMOOTH\_LOCAL\}/bin/} to their path.

The main software source codes and libraries, i.e. all but the main programs, which tend to be quite short, remain in the main branch. If the User believes that they might be editing such files, they might want to copy the entire repository to a location without any fear of having a {\tt git pull} command overwriting their work. The philosophy behind this structure is that it allows the User to devise and build simple programs making calls to {\it Smooth Emulator} libraries without altering the source code and libraries which are kept in the {\tt \$\{SMOOTH\_HOME\}/} directory structure. If the User wished to make modifications to this code, it would make sense to copy the {\tt \$\{SMOOTH\_HOME\}/} directory to a new location. 

\begin{figure}[t]
\centerline{\includegraphics[width = 0.65\textwidth]{figs/directorystructure}}
\caption{\label{fig:directorystructure}{\bf Directory Structure}: The User clones the repository into some location, which will be referred to as {\tt \$\{\tt SMOOTH\_HOME\}}. The User copies the {\tt LocalTemplate} and {\tt AnalysisTemplate} directories to two new locations, {\tt \$\{SMOOTH\_LOCAL\}} and {\tt \$\{MY\_ANALYSIS\}}. The User will likely make multiple copies of the analysis directory for different projects or for different analyses with different options. The main source code and compiled libraries will be built and kept within the {\tt \$\{SMOOTH\_HOME\}/} tree. Source code for simple main programs can be found in {\tt \$\{SMOOTH\_LOCAL\}/software/} and executables are stored in {\tt \$\{SMOOTH\_LOCAL\}/bin/}. The software is designed to be run from the command line in the {\tt \$\{MY\_ANALYSIS\}} directory. Data used and created by {\it Smooth Emulator} software is stored in {\tt \$\{MY\_ANALYSIS\}/smooth\_data/}.
}
\end{figure}

The directory structure is shown in Fig. \ref{fig:directorystructure}. As stated above, for the remainder of this manual, {\tt \$\{SMOOTH\_HOME\}/}, {\tt \$\{SMOOTH\_LOCAL\}/} and {\tt \$\{MY\_ANALYSIS\}/} will be used to denote the location of these directories. 

\subsection{Compiling the Software}

First, change into software directories, then create the makefiles with cmake, then compile them.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{cd ${SMOOTH_HOME}/software}
% \textcolor{darkred}{${SMOOTH_HOME}/software% cmake .}
% \textcolor{darkred}{${SMOOTH_HOME}/software% make}
\end{Verbatim}
}\vspace*{-8pt}
There seems to be a common problem that {\tt cmake} misreports the path of the {\tt Eigen} installation. If the User should get an error stating that the Eigen header files cannot be found, the User can set an environmental variable to point to the correct location, e.g.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{export EIGEN3_INCLUDE_DIR=/opt/homebrew/include/eigen3/}
\end{Verbatim}
}\vspace*{-8pt}
The final arguments may need to be changed depending on the User's location of the packages. If the User wishes to choose a specific C++ compiler, the {\tt cmake} command should be replaced with {\tt cmake -D CMAKE\_CXX\_COMPILER=g++-11}, or whichever compiler is preferred. 

At this point all the libraries are built, but this does not include the main programs. The main programs are short, and are meant to serve as examples which the User might copy and edit at will. Before compiling, one needs to set an environmental variable so that the compilation can find the libraries needed for compilation.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{export SMOOTH_HOME=/Users/CarlosSmith/bandframework/software/SmoothEmulator}
\end{Verbatim}
}\vspace*{-8pt}
The first part of the path needs to be replaced with the location of the {\tt bandframework} git repository. If one prefers not to set an environmental variable, one can instead edit\\
{\tt \$\{SMOOTH\_LOCAL\}/software/CMakeLists.txt}, and replace the line where the variable {\tt \$\{SMOOTH\_HOME\}} is set to the shell's environmental variable with one where it is set explicitly. Another environmental variable that will come into play if (and only if) the User compiles the Python binding software is
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{export SMOOTH_LOCAL=/Users/CarlosSmith/mylocal}
\end{Verbatim}
}\vspace*{-8pt}
The definitions above will change depending on where the User placed the {\it Smooth Emulator} software.

Below, this illustrates how to compile the programs used for all the {\it Smooth Emulator} C++ programs:
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
% \textcolor{darkred}{cd $\{SMOOTH_LOCAL\}/software}
% \textcolor{darkred}{$\{SMOOTH_LOCAL\}/software% cmake .}
% \textcolor{darkred}{$\{SMOOTH_LOCAL\}/software% make}
    .
    .
\end{Verbatim}
}\vspace*{-8pt}
The {\tt cmake} command will also recompile the main libraries in {\tt \$\{SMOOTH\_HOME\}/software/} if necessary. Several source codes for main programs can be found in\\
{\tt \$\{SMOOTH\_LOCAL\}/software/MainPrograms/}. If you build your own main programs (probably using these as examples), you can edit the {\tt CMakeList.txt} file in {\tt \$\{SMOOTH\_LOCAL\}/software/MainPrograms/}, using the existing entries as an example. The executables should appear in {\tt \$\{SMOOTH\_LOCAL\}/bin/}. 

\subsection{The {\tt \$\{MY\_ANALYSIS\}/smooth\_data} Directory}

Within {\tt \$\{MY\_ANALYSIS\}/smooth\_data} there are several sub-directories (assuming it was created from the template). The first is {\tt smooth\_data/Info/}. Information about the model parameters, and their priors is stored in {\tt smooth\_data/Info/prior\_info.txt}, and information about the observables is stored in \sloppypar{\tt smooth\_data/Info/observable\_info.txt}. The file {\tt smooth\_data/Info/experimental\_info.txt} stores information about the measurements for each observable, and is not needed for building the emulator, but is used by the MCMC investigation of the posterior. The \sloppypar{\tt smooth\_data/Options/} directory stores text files used to set options for the training-point optimization, the emulator and the MCMC programs. The {\tt smooth\_data/FullModelRuns} data has subdirectories {\tt run0/}, {\tt run1/} $\cdots$. Each subdirectory stores information describing a full model run. The file \sloppypar{\tt smooth\_data/FullModelRuns/runX/model\_parameters.txt} stores the model parameters used for run ``{\tt X}''. This file can be provided by the User, or it can be created by the training-point optimization codes. Once those files are created, it is the User's responsibility to run the full model and record the observables in {\tt smooth\_data/FullModelRuns/runX/obs.txt}. Given those observables, the User can then run the emulator software. If the User runs the MCMC software, the MCMC traces are stored as text files in {\tt smooth\_data/MCMC\_Trace/}. Examples of Python scripts for graphing using Matplotlib can be found in \sloppypar{\tt smooth\_data/figs/}.


If the User wishes to perform a different analysis, perhaps using a different set of observables, it is recommended to copy {\tt MY\_ANALYSIS} directory and perform the new analysis in that location, so that the previous analysis data is not over-written.

\subsection{Setting up ``Info'' files}
The {\tt smooth\_data/Info/} directory contains three files which the User must create and edit before running any of the {\it Smooth Emulator} software. Each of these files is a simple ascii file. The User may add comments to any of the ``Info'' files by placing the {\tt \#} symbol at the beginning of the line. Only the first file, {\tt smooth\_data/Info/prior\_info.txt} is required for the training-point optimization software. That file and {\tt smooth\_data/Info/observable\_info.txt} are both necessary for emulation. All three files, including {\tt smooth\_data/Info/experimental\_info.txt}, which lists the experimental measurements of the observables used to constrain the model-parameter space, are required for running the MCMC software.

\subsubsection{{\tt smooth\_data/Info/prior\_info.txt}}
This file defines the model parameters and their priors. The format of the simple ascii file is:
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
parameter_name_1  prior_type_1 xmin_1/centroid_1  xmax_1/Rgauss_1  sensivity_scale_1
parameter_name_2  prior_type_2 xmin_2/centroid_2  xmin_2/Rgauss_2  sensivity_scale_2
   .
parameter_name_N  prior_type_N xmin_N/centroid_N  xmin_N/Rgauss_N  sensivity_scale_N
\end{Verbatim}
}\vspace*{-8pt}
For each of the $N$ model parameters the file devotes one line. The first string (no spaces) is the parameter name. The second string describes the prior type, and must be either {\tt gaussian} or {\tt uniform}. The next two entries describe the range of the prior. For uniform priors, the numbers represent the boundaries of the distribution. For a gaussian prior, the first entry represents the centroid of the gaussian and the next entry  represents the gaussian's width. The last entry is the sensitivity scale. If all the model parameters are expected to contribute similarly, all the values should be set to unity. However, if there are some parameters for which one expects to contribute in a more linear fashion (higher orders are less important) one can enter a smaller number. None of the sensitivity scales should exceed unity. For less impactful model parameters, where the User would be satisfied with a nearly linear fit, one enters a number below unity. In practice, this is the same as assuming that the convergence parameter is larger than those with sensitivity scales set to unity, the convergence parameters scales inversely with the sensitivity scale. For example, if the convergence parameter, $\Lambda$, is set to 2.5, setting the sensitivity scale to 0.5 for some model parameter is equivalent to assuming that the effective value of $\Lambda$ for that model parameter is 5.0. 

\subsubsection{{\tt smooth\_data/Info/observable\_info.txt}}
This file describes the observables. It provides only the $n$ observable names and the point-by-point uncertainties.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
observable_name_1   ALPHA_1
observable_name_2   ALPHA_1
   .
observable_name_n   ALPHA_N
\end{Verbatim}
}\vspace*{-8pt}
The measurement uncertainties and the uncertainties due to theoretical systematic error are not provided here -- they are provided in {\tt smooth\_data/Info/experimental\_info.txt}, as they do not come into play until one is comparing the model to measurement or observation. The parameter {\tt ALPHA\_i} describes only the point-by-point uncertainty. This class of uncertainty arises when the full model has some sort of noisy contribution, i.e. one where if the model were re-run with identical model parameters the observable values would vary. Examples of such models would be observables from simulations of nuclear collisions using a finite number of events. If the observable is expected to vary by some representative value $\sigma_A$ throughout the prior, {\tt ALPHA\_i} is the fraction of $\sigma_A$ describing the additional variation due to noise. For example if one believed that a mean transverse momentum measurement from a high-energy collider measurement might vary by 100 MeV throughout the prior, and if the noisy contribution was about 1 MeV, then one would set {\tt ALPHA\_i} to 0.01. If the noise comes from $N_{\rm sample}$ measurements, then one would probably simply set {ALPHA\_i} to $1/\sqrt{N_{\rm sample}}$. This parameter ensures that should the User choose two training points that are nearly adjacent, the emulator will not attempt to exactly reproduce both points, which would lead to wildly varying, non-smooth, behavior.

\subsubsection{{\tt smooth\_data/Info/observable\_info.txt}}
The third file describes the measurement and their uncertainties. It is only used when performing the MCMC fit, which occurs after the emulator is trained. The format is
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
observable_name_1   measurement_1  exp_uncertainty_1   theory_uncertainty_1
observable_name_2   measurement_2  exp_uncertainty_2   theory_uncertainty_2
   .
observable_name_N   measurement_N  exp_uncertainty_N   theory_uncertainty_N
\end{Verbatim}
}\vspace*{-8pt}
The observable names must be identical, or a subset, of those from {\tt smooth\_data/Info/observable\_info.txt}. The measurements and their uncertainties are typically taken from the experimental publication. The last entry in each line is the systematical theoretical uncertainty, i.e. that arising from the physics missing from the model. For example, if the model is missing a certain bit of physics, or if that physics is described through an imperfect approximation, then one would expect the model calculations to vary from the experimental values even if the model parameters were perfectly chosen. In practice, the two uncertainties contribute as a single uncertainty, where the two are added in quadrature. 

\subsection{Testing the Installation}
The User can go to the tutorial analysis directory created by copying the template. There should be a script there, {\tt \$\{MY\_ANALYSIS\}/software\_test.sh}. This script runs all the commands used in the tutorial. This includes generating figures. The script calls a PDF viewer to open pre-made versions of the plots and compare the newly generated plots to the pre-made versions.
\vspace*{-8pt}{\tt \begin{Verbatim}[commandchars=\\\{\}]
$\{MY_ANALYSIS\}% \textcolor{darkred}{source software_test.sh}
\end{Verbatim}
}\vspace*{-8pt}
If all goes well, three pairs of matching figures  should ultimately appear.\\
\begin{minipage}{0.5\textwidth}
\includegraphics[width=0.9\textwidth]{figs/YvsY_tutorial.pdf}
\includegraphics[width=\textwidth]{figs/posterior_tutorial.pdf}
\end{minipage}
\hspace{1.0in}
\begin{minipage}{0.275\textwidth}
\includegraphics[width=\textwidth]{figs/RP_tutorial.pdf}
\end{minipage}

\begin{figure}
\caption{Figures created by the {\tt software\_test.sh} script. These same figures will be created by completing the tutorial in Sec. \ref{sec:tutorial}}
\end{figure}

\end{document}
